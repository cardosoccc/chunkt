#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import json
import copy
import hashlib
import mistune
import scipy.stats as st

from jinja2 import Template
from bs4 import BeautifulSoup
from flask import Flask, render_template, request

################################################################################
# CONSTANTS
################################################################################

ROOT_DIR = os.getenv('HOME') + '/.chunkt'
CHUNKTS_FILE = ROOT_DIR + '/chunktfile.json'

################################################################################
# TEMPLATES
################################################################################

INDEX_TEMPLATE = '''
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>chunkt</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <head>
    <body>
        <div class="container-fluid">
            <div class="row">
                <div class="panel panel-default">

                    <div class="panel-heading">
                        <h1 class="panel-title">chunkt</h1>
                    </div>
                    <div class="panel-body">
                        <div id="chunkts" class="list-group">
                        {% for chunkt in chunkts %}
                            <a href="/{{ chunkt.hash }}/pull" class="list-group-item">{{ chunkt.path }}</a>
                        {% endfor %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>'''

CHUNK_TEMPLATE = '''
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>chunkt</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script>
            $(function() {
                $("#show").on('click', function() { $(".action-btn-group, .back").toggleClass('hide') }).focus();
            });
        </script
    <head>
    <body>
        <div class="container-fluid">
            <div class="row">
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h1 class="panel-title">{{ ' / '.join(chunkt.path.split('/')) }}</h1>
                    </div>
                    <div class="panel-body">
                        <ul class="front list-group">
                            <li class="list-group-item">{{ chunk.front() }}</li>
                        </ul>
                        <ul class="back list-group hide">
                        {% for child_content in chunk.back() %}
                            <li class="list-group-item">{{ child_content }}</li>
                        {% endfor %}
                        </ul>
                        <div class="action-btn-group btn-group btn-group-justified" role="group">
                            <div class="btn-group" role="group">
                                <button id="show" type="button" class="btn btn-default">
                                    <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
                                </button>
                            </div>
                        </div>
                        <div class="action-btn-group btn-group btn-group-justified hide" role="group">
                            <div class="btn-group" role="group">
                                <button id="reward1" type="button" class="btn btn-default">
                                    <span class="glyphicon glyphicon-remove" aria-hidden="true"></span>
                                </button>
                            </div>
                            <div class="btn-group" role="group">
                                <button id="reward0" type="button" class="btn btn-default">
                                    <span class="glyphicon glyphicon-ok" aria-hidden="true"></span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>'''

################################################################################
# APP
################################################################################

app = Flask(__name__)

################################################################################
# CHUNK
################################################################################

class Chunk:
    
    def __init__(self, el, registry, func=None, depth=0):
        self.depth = depth
        self.children = []
        matched = re.match('[hH]([0-9])', el.name) 
        
        if matched:
            self._handle_titles(el, registry, func, matched)
        elif el.name == 'li':
            self._handle_list_items(el, registry, func)

        if func:
            func(self, registry)

    def _handle_titles(self, el, registry, func, matched):
        level = int(matched.group(1))
        self.content = el.renderContents()

        for sibling in el.next_siblings:
            if not sibling.name:
                continue
                
            s_matched = re.match('[hH]([0-9])', sibling.name)
            s_level = s_matched and int(s_matched.group(1))
            if s_matched and s_level > level:
                self.children.append(Chunk(sibling, registry, func=func, depth=self.depth+1))
            elif s_matched and s_level <= level:
                break

        if len(self.children) > 0:
            return

        ul = el.select_one('~ ul')
        for li in ul.select('> li'):
            self.children.append(Chunk(li, registry, func=func, depth=self.depth+1))

    def _handle_list_items(self, el, registry, func):
        p = el.find('p')
        ul = el.select_one('ul')
        
        if p and not ul:
            self.content = p.renderContents()
        elif not p and not ul:
            self.content = el.renderContents()
        elif ul:
            self.content = self._extract_list_item_content(el)
            for li in ul.select('> li'):
                self.children.append(Chunk(li, registry, func=func, depth=self.depth+1))

    def _extract_list_item_content(self, el):
        content = ''
        for c in el.children:
            if c.name == 'p':
                content += c.renderContents()
            elif c.name != 'ul': 
                content += c.extract().strip()

        return content

    def front(self):
        return self.content

    def back(self):
        back = []
        for child in self.children:
            back.append(child.content)
        return back

    def hash(self):
        return hashlib.md5(self.front() + ''.join(self.back())).hexdigest()


################################################################################
# CHUNKT
################################################################################

class Chunkt:
    
    def __init__(self, path, hash, root_dir=ROOT_DIR):
        self.hash = hash
        self.path = path
        self.root_dir = root_dir
        self._registry = None
        self._root = None
        self._content_hash = None
        self.loaded = False

    def absolute_path(self):
        return '%s/%s' % (self.root_dir, self.path)

    def root(self):
        if not self.loaded:
            self.load()
        return self._root

    def content_hash(self):
        if not self.loaded:
            self.load()
        return self._content_hash

    def registry(self):
        if not self.loaded:
            self.load()
        return self._registry

    def load(self, func=None):
        with open(self.absolute_path()) as markdown:
            content = markdown.read()
            html = mistune.markdown(content)
            h1 = BeautifulSoup(html, 'lxml').select_one('h1')
            self._content_hash = (hashlib.md5(content).hexdigest())
            self._registry = {} 
            self._root = Chunk(h1, self._registry, func=func)
            self.loaded = True
        
################################################################################
# BANDIT
################################################################################

class Bandit:

    def __init__(self, chunkt, info):
        self.chunkt = chunkt
        self.info = info

    def pull(self):
        best_arm = None
        highest_sample = -float('inf')
        
        for arm_hash, arm_info in self.info['arms'].iteritems():
            sample = st.beta(1 + arm_info['hits'], 1 + arm_info['misses']).rvs()
            if sample > highest_sample:
                best_arm = arm_hash
                highest_sample = sample

        return self.chunkt.registry()[best_arm]

################################################################################
# BANDIT ENGINE
################################################################################

class BanditEngine:
    
    def __init__(self, data):
        self.data = data

    def fix_chunkt_hashes(self, chunkt):
        hash_exists = chunkt.hash in self.data
        if hash_exists: 
            self.data[chunkt.hash]['content_hash'] = chunkt.content_hash()
        else:
            data_copy = copy.deepcopy(self.data)
            for chunkt_hash, info in data_copy.iteritems():
                if info['content_hash'] == chunkt.content_hash():
                    info['path'] = chunkt.path
                    self.data[chunkt.hash] = info
                    del self.data[chunkt_hash]
                    break

    def fix_chunks_hashes(self, chunkt):
        active_chunks_hashes = set(chunkt.registry().keys())
        current_bandit_hashes = set(self.data[chunkt.hash]['arms'].keys())
        obsolete_hashes = current_bandit_hashes - active_chunks_hashes
        new_hashes = active_chunks_hashes - current_bandit_hashes
        for h in obsolete_hashes:
            del self.data[chunkt.hash]['arms'][h]
        for h in new_hashes:
            self.data[chunkt.hash]['arms'][h] = {'misses': 0, 'hits': 0}

    def _post_create_chunk(self, chunk, registry):
        if len(chunk.children) > 0:
            registry[chunk.hash()] = chunk


    def initialize_data(self, chunkt):
        data = self.data.get(chunkt.hash)
        if not data:
            self.data[chunkt.hash] = {
                'content_hash': chunkt.content_hash(),
                'path': chunkt.path,
                'arms': {}
            }

    def update(self, chunkt):
        chunkt.load(self._post_create_chunk)
        self.fix_chunkt_hashes(chunkt)
        self.initialize_data(chunkt)
        self.fix_chunks_hashes(chunkt)

    def load(self, chunkt):
        info = self.data[chunkt.hash]
        return Bandit(chunkt, info)


################################################################################
# BANDIT REPOSITORY
################################################################################

def load_engine_data():
    with open(CHUNKTS_FILE, 'r') as bandits_file:
        return json.loads(bandits_file.read())

def save_engine_data(bandit_engine):
    with open(CHUNKTS_FILE, 'w') as bandits_file:
        bandits_file.write(json.dumps(bandit_engine.data))

def load_bandit(chunkt):
    bandit_engine = BanditEngine(load_engine_data())
    bandit_engine.update(chunkt)
    save_engine_data(bandit_engine)
    return bandit_engine.load(chunkt)

################################################################################
# CHUNKT REPOSITORY
################################################################################

def all_chunkts():
    chunkts = []
    for root, dirs, files in os.walk(ROOT_DIR):
        for f in files:
            if f.endswith(".md"):
                chunkt_path = os.path.join(root.split('.chunkt/')[1], f)
                chunkt_hash = hashlib.md5(chunkt_path).hexdigest()
                chunkts.append(Chunkt(chunkt_path, chunkt_hash))
    
    return sorted(chunkts, key=lambda x: x.path)

def find_chunkt(chunkt_hash):
    for chunkt in all_chunkts():
        if chunkt.hash == chunkt_hash:
            return chunkt


################################################################################
# WEB SERVER
################################################################################

@app.route('/')
def index():
    return Template(INDEX_TEMPLATE).render(chunkts=all_chunkts())

@app.route('/<chunkt_hash>/pull')
def pull(chunkt_hash):
    chunkt = find_chunkt(chunkt_hash)
    if not chunkt:
        return 'Chunkt not found', 404

    bandit = load_bandit(chunkt)
    chunk = bandit.pull()
    return Template(CHUNK_TEMPLATE).render(chunkt=chunkt, chunk=chunk)

@app.route('/<chunkt_hash>/reward', methods=['POST'])
def reward(chunkt_hash):
    # check if chunkt exists and if pull id is in memory
    # if not, return
    # if it is, update the bandit info
    return 'notify reward and and pull again: %s %s %s' % (chunkt, pull, request.get_json())

@app.before_request
def bootstrap():
    if not os.path.exists(ROOT_DIR):
        os.makedirs(ROOT_DIR)
    if not os.path.exists(CHUNKTS_FILE):
        with open(CHUNKTS_FILE, 'w') as bandits_file:
            bandits_file.write('{}\n')


if __name__ == '__main__':
    app.run(debug=True)